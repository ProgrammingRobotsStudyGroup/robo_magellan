#!/usr/bin/env python3

import rospy
import os
import re
import serial
import subprocess
import sys
import threading
import time
from math import pi
from std_msgs.msg import Bool, Float32, Int8, Int16

nodeLock = threading.Lock()

class Receiver():
    def __init__(self):
        self.node_name = 'arduino_receiver'

        rospy.init_node(self.node_name)

        self.publish_touch = rospy.get_param('~publish_touch', True)
        self.touch_sensor_count = rospy.get_param('~touch_sensor_count', 0)
        self.touch_sensors_pub = []
        self.wheel_diameter = rospy.get_param('~wheel_diameter', 0.200)
        self.ticks_per_revolution = rospy.get_param('~ticks_per_revolution', 80)
        port = rospy.get_param('~serial_device', '/dev/ttyACM0')
        baud = rospy.get_param('~serial_rate', 115200)

        # Attempt to find the right connection?
        # Connect to serial port, with retry
        MAX_TRY = 20
        retries = 0
        while True:
            try:
                self.serial_port = serial.Serial(port, baud)
                break
            except:
                if rospy.is_shutdown():
                    rospy.logwarn("ROS is shutting down")
                    sys.exit()
                time.sleep(2)
                retries += 1
                if retries >= MAX_TRY:
                    raise Exception('Failed to connect to: '+port)
                rospy.logwarn("Retry connect to: "+port)

        if self.publish_touch:
            self.touch_pub = rospy.Publisher("/robo_magellan/touch", Bool, queue_size = 1)
            # If we have a sensor count >0, create a publisher for each
            if self.touch_sensor_count > 0:
                for index in range(self.touch_sensor_count):
                    self.touch_sensors_pub.append(rospy.Publisher("/robo_magellan/touch"+str(index), Bool, queue_size = 1))
        self.speed_pub = rospy.Publisher("/robo_magellan/speed", Float32, queue_size = 1)
        self.enc_pub = rospy.Publisher("/robo_magellan/encoder_distance", Float32, queue_size = 1)
        
        self.last_display_update = 0.0
        self.fix = 0
        self.last_ticks = None

        rospy.loginfo('{0}: Ready.'.format(self.node_name))

    def run(self):
        # Compile regex expressions
        # Touch
        re_touch_orig = re.compile('^B ([-0-9]+)')
        re_touch = re.compile('^B(\s[-0-9]+)*')
        re_digits = re.compile('([-0-9]+)')
        # Encoder
        re_encoder = re.compile('^E ([-0-9]+) ([-0-9]+) ([-0-9]+)')

        while not rospy.is_shutdown():
            t = time.time()

            if t - self.last_display_update > 1.0:
                self.last_display_update = t

                led_string = "l "

                if self.fix == 0:
                    led_string += "255 0 0\n"
                elif self.fix == 1:
                    led_string += "0 90 90\n"
                elif self.fix == 2:
                    led_string += "0 140 0\n"
                elif self.fix == 3 or self.fix == 4:
                    led_string += "225 200 15\n"
                elif self.fix == 5:
                    led_string += "210 121 34\n"
                else:
                    led_string += "255 0 0\n"

                self.serial_port.write(bytes(led_string, 'ascii'))

            try:
                l = str(self.serial_port.readline(), 'utf-8')
                if l:
                    l = l.rstrip()
                    # rospy.loginfo("%s: line=%s" % (self.node_name, l))

                    if self.publish_touch:
                        # # Backward compatibility
                        # # /robo_magellan/touch gets same msgs as /robo_magellan/touch0
                        # m = re_touch_orig.match(l)
                        # if m:
                        #     value = int(m.group(1))
                        #     # rospy.loginfo("%s: Receiver got %d" % (self.node_name, value))
                        #     self.touch_pub.publish(value != 0)

                        # Check for touch switch message w/ 'n' touch sensors 
                        m = re_touch.match(l)
                        if m:
                            touch_values = re_digits.findall(l)
                            any_touch = 0
                            # If we have a sensor count >0, publish the sensor's value
                            if self.touch_sensor_count > 0:
                                for index in range(self.touch_sensor_count):
                                    value = int(touch_values[index])
                                    self.touch_sensors_pub[index].publish(value != 0)
                                    if (value>0): 
                                        any_touch = 1
                            # If any sensor detects touch, publish /robo_magellan/touch=true
                            self.touch_pub.publish(any_touch)

                    m = re_encoder.match(l)
                    # Groups are:
                    #   0 = entire match
                    #   1 = period in ms
                    #   2 = left ticks
                    #   3 = right ticks

                    if m:
                        # rospy.loginfo("%s: Receiver E got %d" % (self.node_name, value))
                        # Speed in m/s is:
                        #   pi*diameter*dticks/ticks_per_revolution / period
                        # Convert period to seconds.
                        period = 0.001 * int(m.group(1))
                        s = 0
                        value = int(m.group(2))
                        if self.last_ticks is not None:
                            delta = value - self.last_ticks
                            s = pi*self.wheel_diameter \
                                * (float(delta) / self.ticks_per_revolution) \
                                / period
                            # rospy.loginfo('%s: Receiver E value= %d period= %f s= %f', self.node_name, value, period, s)
                            self.speed_pub.publish(s)
                        self.last_ticks = value

                        # Distance is speed * time.
                        d = s * period
                        self.enc_pub.publish(d)
            except serial.serialutil.SerialException:
                rospy.loginfo("close serial")

        rospy.loginfo("%s: Done." % self.node_name)
        self.serial_port.close()

def main(args):
    try:
        Receiver().run()

    except KeyboardInterrupt:
        rospy.loginfo("close")

if __name__ == '__main__':
    main(sys.argv)
